{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hello! \ud83d\udc4b I'm Leynier Guti\u00e9rrez Gonz\u00e1lez \ud83d\udc68\ud83c\udffb\u200d\ud83d\udcbb","text":"<p>I'm a Computer Science graduate. I know several programming languages such as C, C++, C#, Dart, Java, Python, and Javascript; in addition to other markup or style languages such as HTML, CSS, and JSON. I really like both mobile application development and web application development, using frameworks, software, technologies, etc; like Android Studio, Flutter, Unity, Flask, FastAPI, Vue.js, and Bootstrap.</p> <p>In my free time, I am always researching and learning about new technologies, frameworks, etc. I am good at working both individually and as a team, I know the development methodologies of agile software and tools like Git.</p>"},{"location":"#statistics","title":"Statistics","text":""},{"location":"#activity-chart","title":"Activity Chart","text":""},{"location":"#skills-chart","title":"Skills Chart","text":""},{"location":"#github-stats","title":"GitHub Stats","text":""},{"location":"#github-trophies","title":"GitHub Trophies","text":""},{"location":"#experience","title":"Experience","text":""},{"location":"#head-of-engineering-at-educup","title":"Head of Engineering at EducUp","text":"<p>January 2021 - Present</p> <p>I lead a team of developers, both frontend and backend, in which we use agile methodologies and technologies such as ASP.Net Core, Unity, Flutter, FastAPI, Firebase, AWS, among others.</p>"},{"location":"#cto-co-founder-at-mesirve","title":"CTO &amp; Co-founder at MeSirve","text":"<p>August 2021 - Present</p> <p>An app for business. And all businesses for an app. Create your 100% free store today and join the progress \ud83d\ude80.</p>"},{"location":"#professor-at-the-matcom","title":"Professor at the MatCom","text":"<p>December 2021 - Present</p> <p>An app for business. And all businesses for an app. Create your 100% free store today and join the progress \ud83d\ude80.</p>"},{"location":"#flutter-developer-at-educup","title":"Flutter Developer at EducUp","text":"<p>January 2020 - December 2020</p> <p>Mainly developing mobile applications using the Flutter framework, but also maintaining mobile applications developed with Unity, as well as implementing systems and tools using Dart, Python and C#.</p>"},{"location":"#unity-developer-at-viera-academy","title":"Unity Developer at Viera Academy","text":"<p>September 2018 - April 2021</p> <p>Member of the applications development team. In charge mainly of the functionalities related to third party services such as Unity IAP, Google Firebase, etc.</p>"},{"location":"#assistant-student-at-university-of-havana","title":"Assistant Student at University of Havana","text":"<p>September 2019 - March 2021</p> <p>Assistant Student of Computer Networks in the Faculty of Mathematics and Computing and of Computing and Programming at the Faculty of Biology of the University of Havana.</p>"},{"location":"#trained-at-cuban-neuroscience-center","title":"Trained at Cuban Neuroscience Center","text":"<p>July 1, 2019 - July 18, 2019</p> <p>Member of a team responsible for migrating and implementing new functionalities of an application made in Matlab on the analysis of the gait which from sensors that measure acceleration, direction, etc; calculates different parameters such as the number of steps, the step length, the step speed, etc. The new application was implemented in the Python programming language.</p>"},{"location":"#education","title":"Education","text":""},{"location":"#university-of-havana","title":"University of Havana","text":"<p>Bachelor's Degree, Computer Science. September 2016 - December 2021</p> <p>Student of Computer Science of the Faculty of Mathematics and Computation of the University of Havana. I have represented the faculty and the university in many events such as the International Girls' Day on ICTs developed at the Cuba Security Center, the ICT Boulevard developed at the Central Palace of Computing and Electronics of Cuba, etc.</p>"},{"location":"#ipvce-vladimir-ilich-lenin","title":"IPVCE Vladimir Ilich Lenin","text":"<p>High School, Pre University. September 2012 - July 2015</p> <p>I was part of the high performance group, specifically in the Computer Science course. Among the awards can be highlighted the Gold at the provincial level and the Bronze at the national level in the Competitive Programming Contests. Proudly a member of Graduation 41.</p>"},{"location":"#projects","title":"Projects","text":""},{"location":"#courses","title":"Courses","text":"<ul> <li>Algebra I and II</li> <li>Algorithm Design and Analysis</li> <li>Analytic Geometry</li> <li>Compilation</li> <li>Computer Networks</li> <li>Data Structure and Algorithms I and II</li> <li>Database Systems I and II</li> <li>Discrete Mathematics I and II</li> <li>Distributed Systems</li> <li>Image Processing</li> <li>Machine Programming I and II</li> <li>Mathematical Analysis I and II</li> <li>Mathematical Logic</li> <li>Numerical Mathematics I and II</li> <li>Operating Systems</li> <li>Ordinary Differential Equations</li> <li>Programming</li> <li>Programming Languages</li> <li>Software Engineering</li> </ul>"},{"location":"#certificates","title":"Certificates","text":""},{"location":"#skills","title":"Skills","text":"<ul> <li>Knowledges: Software Development | Software Design | Software Engineering | Web Development | Mobile Development</li> <li>Programming Languages: C | C++ | C## | Python | Dart | Java | Assembly Language | JavaScript | SQL | Ruby</li> <li>Markup and Style Languages: HTML5 | CSS | JSON</li> <li>Frameworks and Technologies: Flask | Android | Unity3D | Flutter | Bootstrap | Vue.js | AngularJS | SQLAlchemy | Windows Forms | Windows Presentation Fundation</li> <li>Tools: Google Firebase | pipenv | Git</li> </ul>"},{"location":"#languages","title":"Languages","text":"<ul> <li>Spanish: It is my native language.</li> <li>English: Intermediate basic level.</li> </ul>"},{"location":"blog/","title":"Blog - Last Posts","text":"<ul> <li>Inferfuzzy (October 30, 2020)</li> <li>Hidato-Haskell (October 25, 2020)</li> <li>Cuba Weather - De Cuba Para Cuba (October 24, 2020)</li> </ul>"},{"location":"blog/cuba-weather-de-cuba-para-cuba/","title":"Cuba Weather - De Cuba Para Cuba","text":"<p>Leynier Guti\u00e9rrez Gonz\u00e1lez | October 24, 2020</p> <p></p> <p>Cuba Weather es un proyecto pionero en Cuba de c\u00f3digo abierto, multiplataforma y sin \u00e1nimo de lucro, cuyo objetivo es brindar a los residentes en Cuba una manera c\u00f3moda de acceder a informaci\u00f3n meteorol\u00f3gica obtenida de fuentes nacionales utilizando solo navegaci\u00f3n nacional (por ejemplo, el bono de 300 megabytes nacionales de los paquetes de datos). A poco m\u00e1s de un mes de subida en Apklis ha alcanzado m\u00e1s de 27 mil descargas, varios reportes en medios digitales, una gran contribuci\u00f3n de los usuarios mediante sugerencias y donaciones, colaboraci\u00f3n y asesoramiento de especialistas del INSMET y mejoras implementadas por varios desarrolladores creando en poco tiempo una comunidad entusiasta alrededor del proyecto.</p> <p>El proyecto es de c\u00f3digo fuente abierto, pues es objetivo de sus creadores fomentar el software libre y el c\u00f3digo abierto en Cuba. Todos los c\u00f3digos relacionados con el proyecto se encuentran en GitHub bajo la organizaci\u00f3n Cuba Weather (https://github.com/cuba-weather).</p> <p>Para el desarrollo de la aplicaci\u00f3n Android se utiliz\u00f3 Flutter (SDK de c\u00f3digo fuente abierto de desarrollo de aplicaciones m\u00f3viles creado por Google. Suele usarse para desarrollar interfaces de usuario para aplicaciones en Android, iOS y Web, as\u00ed como m\u00e9todo primario para crear aplicaciones para Google Fuchsia).</p> <p>Solo se utiliza informaci\u00f3n meteorol\u00f3gica extra\u00edda de fuentes nacionales, por lo que no es necesario de navegaci\u00f3n internacional, ampliando la gama de opciones disponibles de la navegaci\u00f3n nacional diferenci\u00e1ndose de otras aplicaciones y contribuyendo con la informatizaci\u00f3n del pa\u00eds.</p> <p>En la versi\u00f3n actual de la aplicaci\u00f3n se obtienen los datos del sitio web oficial del Instituto de Meteorolog\u00eda de Cuba (http://www.insmet.cu), del cual se obtienen los pron\u00f3sticos extendidos del d\u00eda actual y del siguiente, las perspectivas del tiempo y los pron\u00f3sticos para varios d\u00edas en adelante. Adem\u00e1s, se utiliza informaci\u00f3n extra\u00edda del buscador cubano RedCuba (https://www.redcuba.cu) como la temperatura, la humedad, la presi\u00f3n atmosf\u00e9rica y la velocidad y direcci\u00f3n del viento con un periodo de actualizaci\u00f3n de 2 a 3 horas.</p> <p>Ha contado con una gran colaboraci\u00f3n de parte de reconocidos meteor\u00f3logos como Elier Pila, de la comunidad de desarrolladores de Cuba y de los usuarios, quienes han contribuido de diversas formas, entre ellas, donaciones. Estas donaciones son utilizadas para pagar infraestructura como el dominio (https://cubaweather.app), un hosting de Etecsa para la versi\u00f3n web del proyecto, licencias de desarrollador para las principales tiendas (Google Play y Apple Store). En ning\u00fan caso, estas son utilizadas para beneficio propio de alguno de sus desarrolladores.</p> <p>Actualmente est\u00e1 disponible una aplicaci\u00f3n para Android publicada en Apklis (https://www.apklis.cu/application/com.codestrange.www.cuba_weather).</p>"},{"location":"blog/hidato-haskell/","title":"Hidato - Haskell","text":"<p>Carlos Bermudez Porto y Leynier Guti\u00e9rrez Gonz\u00e1les | October 25, 2020</p> <p></p> <p>Repositorio de GitHub</p>"},{"location":"blog/hidato-haskell/#significado-de-haskell","title":"Significado de Haskell","text":"<p>Haskell es un lenguaje de programaci\u00f3n estandarizado multi-prop\u00f3sito, funcionalmente puro, con evaluaci\u00f3n no estricta y memorizada, y fuerte tipificaci\u00f3n est\u00e1tica. Su nombre se debe al l\u00f3gico estadounidense Haskell Curry, debido a su aportaci\u00f3n al c\u00e1lculo lambda, el cual tiene gran influencia en el lenguaje. En Haskell, \"una funci\u00f3n es un ciudadano de primera clase\" del lenguaje de programaci\u00f3n. Como lenguaje de programaci\u00f3n funcional, el constructor de controles primario es la funci\u00f3n. El lenguaje tiene sus or\u00edgenes en las observaciones de Haskell Curry y sus descendientes intelectuales. [1]</p>"},{"location":"blog/hidato-haskell/#significado-de-hidato","title":"Significado de Hidato","text":"<p>Hidato es un juego de l\u00f3gica creado por el Dr. Gyora Benedek, un matem\u00e1tico israel\u00ed. El objetivo de Hidato es rellenar el tablero con n\u00fameros consecutivos que se conectan horizontal, vertical o diagonalmente. Los puzzles Numbrix, creados por Marilyn Vos Savant, son similares a Hidato excepto por los movimientos diagonales, que no est\u00e1n permitidos. Los nombres Numbrix e Hidato son marcas registradas. [2]</p>"},{"location":"blog/hidato-haskell/#explicacion-del-hidato","title":"Explicaci\u00f3n del Hidato","text":"<p>En el Hidato, el objetivo es rellenar el tablero con n\u00fameros consecutivos que se conectan horizontal, vertical o diagonalmente. En cada juego de Hidato, los n\u00fameros mayor y menor est\u00e1n marcados en el tablero. Todos los n\u00fameros consecutivos est\u00e1n adyacentes de forma vertical, horizontal o diagonal. Hay algunos n\u00fameros m\u00e1s en el tablero para ayudar a dirigir al jugador sobre c\u00f3mo empezar a resolverlo y para asegurarse de que ese Hidato tiene soluci\u00f3n \u00fanica. Se suele jugar en una cuadr\u00edcula como Sudoku pero tambi\u00e9n existen tableros hexagonales u otros m\u00e1s irregulares con figuras como corazones, calaveras, etc. Cada puzzle de Hidato creado correctamente debe tener soluci\u00f3n \u00fanica.</p> <p></p> <p>Un puzzle Hidato y su soluci\u00f3n</p>"},{"location":"blog/hidato-haskell/#modelacion-del-hidato","title":"Modelaci\u00f3n del Hidato","text":"<p>Para representar el tablero del juego Hidato se utiliz\u00f3 una tupla de 3 elementos <code>(nRows, nCols, setCells)</code>. En lo adelante, cuando se haga referencia a un tablero de Hidato se har\u00e1 referencia a la tupla <code>(nRows, nCols, setCells)</code>.</p> <p>nRows: <code>x \u2208 \u039d</code>. Representa la cantidad de filas del tablero</p> <p>nCols: <code>x \u2208 \u039d</code>. Representa la cantidad de columnas del tablero</p> <p>setCells: El conjunto <code>S</code> de todos los vectores <code>\u2329x, y, v\u232a</code> donde <code>x, y \u2208 \u039d, 1 \u2264 x \u2264 nRows, 1 \u2264 y \u2264 nCols, v \u2208 \u0396, -1 \u2264 v, \u2200 \u2329x1, y1\u232a \u2208 ([1, nRows]\u00d7[1, nCols]) \u2229 Z x Z</code> el conjunto <code>S</code> contiene un \u00fanico vector <code>\u2329x2, y2, v2\u232a</code> tal que <code>x1 = x2</code> y <code>y1 = y2</code>, no existen <code>2</code> vectores <code>\u2329x1, y1, v1\u232a \u2208 S y \u2329x2, y2, v2\u232a \u2208 S tal que x1 \u2260 x2, y1 \u2260 y2, v1 &gt; 0, v2 &gt; 0 y v1 = v2; y v \u2264 nRows * nCols - |{\u2329x1, y1, v1\u232a | \u2329x1, y1, v1\u232a \u2208 S \u2227 v1 = -1}|</code>. Conjunto de vectores donde cada uno representa una celda en el tablero. La primera y segunda componente del vector representan la fila y columna respectivamente en la que se encuentra la celda dentro del tablero y la tercera componente representa el valor de la celda en el tablero. Estos valores son todos mayores iguales a <code>-1</code> y representan lo siguiente:</p> <ul> <li><code>-1</code> representa un obst\u00e1culo, esa celda no se utiliza para el juego, de esta manera se pueden representar juegos de Hidato de la forma que se quiera utilizando obst\u00e1culos (Externamente para el usuario se representa con <code>'x'</code>)</li> <li><code>0</code> Representa una celda en blanco, la cual debe ser rellenada para solucionar el Hidato (Externamente para el usuario se representa con <code>'.'</code>)</li> <li>Mayor que <code>0</code> representa una celda con un n\u00famero rellenado ya sea porque estaba as\u00ed en un inicio o porque fue rellenado durante el proceso de resoluci\u00f3n del Hidato.</li> </ul> <p>Ejemplo visual de un tablero de Hidato</p> <p></p> <p>Plantilla de Hidato v\u00e1lida de 5x5 e Hidato resuelto de 5x5</p> <p>Se define como una plantilla de Hidato a un tablero donde <code>setCells</code> no contenga vectores con valores mayores que <code>1</code> en su tercera componente.</p> <p>Se define como una plantilla de Hidato v\u00e1lida a una plantilla de Hidato si partiendo desde ella y realizando transformaciones v\u00e1lidas al conjunto setCells es posible llegar a un Hidato resuelto.</p> <p>Las transformaciones v\u00e1lidas son aquellas que a partir de un tablero de Hidato se escoge un vector del conjunto <code>setCells</code> tal que su tercera componente sea igual a <code>0</code> y se modifica esa componente colocando un valor diferente de <code>0</code> siempre y cuando el resultado sea un tablero de Hidato.</p> <p>Se define que <code>2</code> vectores <code>\u2329x1, y1, v1\u232a</code> y <code>\u2329x2, y2, v2\u232a</code>  del conjunto <code>setCells</code> de un tablero de Hidato son adyacentes si existe <code>\u2329x3, y3\u232a \u2208 ([-1, 1]\u00d7[-1, 1]) \u2229 Z x Z - {\u23290, 0\u232a}</code> tal que <code>\u2329x1, y1\u232a=\u2329x2, y2\u232a+\u2329x3, y3\u232a</code>.</p> <p>Se define como un Hidato resuelto a un tablero de Hidato que no contenga vectores en <code>setCells</code> con la tercera componente igual a <code>0</code> y que <code>\u2200 \u2329x1, y1, v1\u232a \u2208 setCells</code> con <code>v1 &gt; 1</code> existe un vector <code>\u2329x2, y2, v2\u232a \u2208 setCells</code> que es adyacente con <code>\u2329x1, y1, v1\u232a</code> donde <code>v1 = v2 + 1</code>.</p>"},{"location":"blog/hidato-haskell/#algoritmo-de-solucion","title":"Algoritmo de Soluci\u00f3n","text":"<p>La idea general del algoritmo de soluci\u00f3n es utilizar un recorrido por el grafo de posibles transformaciones v\u00e1lidas utilizando el algoritmo de b\u00fasqueda en profundidad o mejor conocido como DFS.</p> <p>La funci\u00f3n solve recibe un tablero, un paso y un l\u00edmite (este l\u00edmite es igual al mayor n\u00famero posible dentro del tablero o sea el mayor v) y realiza lo siguiente:</p> <ul> <li>Si el paso es igual al l\u00edmite m\u00e1s uno es que el tablero est\u00e1 rellenado completo y por tanto se resolvi\u00f3 completamente, por lo que devuelve una lista conteniendo al tablero.</li> <li>Si no, devuelve una lista resultante de concatenar las listas de tableros resultantes del proceso de utilizar cada tablero generado por la invocaci\u00f3n de la funci\u00f3n stepMatrix pas\u00e1ndole los argumentos del tablero actual y el paso actual como argumento de un llamado recursivo a la funci\u00f3n solve con el paso siguiente y el mismo l\u00edmite.</li> </ul> <p>La funci\u00f3n stepMatrix recibe un tablero y un paso y realiza lo siguiente:</p> <ul> <li>Si hay alguna celda con el valor igual al paso actual dentro del tablero actual y bien ese valor es 1 o la celda es adyacente con la celda que tiene el valor del paso anterior dentro del tablero actual devuelve una lista conteniendo al tablero actual.</li> <li>Si hay alguna celda con el valor igual al paso actual dentro del tablero actual y el valor NO es 1 y la celda NO es adyacente con la celda que tiene el valor del paso anterior dentro del tablero actual devuelve una lista vac\u00eda.</li> <li>Si no, devuelve una lista que contiene a los tableros resultantes del proceso de recorrer cada celda adyacente (que su valor sea diferente de 0) de la celda que tiene el valor del paso anterior dentro del tablero generando por cada una de estas celdas adyacentes un nuevo tablero con el valor de esa celda igual al paso actual.</li> </ul> <p>Ejemplo de pseudo implementaci\u00f3n en Python del algoritmo de soluci\u00f3n.</p> <pre><code>def solve(table, step, limit):\n    if step == limit + 1:\n        return [table]\n    else:\n        return [\n            item\n            for new_table in step_matrix(table, step)\n            for item in solve(new_table, step + 1, limit)\n        ]\n\ndef step_matrix(table, step):\n    if cell_in_table(step, table):\n        if get_cell_value(get_cell(table, step)) == 1 or is_adyacents(get_cell(table, step), get_cell(table, step - 1)):\n            return [table]\n        else:\n            return []\n    else:\n        return [\n            update_cell_in_table(table, update_value_in_cell(step, cell))\n            for cell in get_adyacents(table, get_cell(table, step - 1))\n            if get_cell_value(cell) == 0\n        ]\n</code></pre>"},{"location":"blog/hidato-haskell/#algoritmo-de-generacion","title":"Algoritmo de Generaci\u00f3n","text":"<p>La idea general del algoritmo de generaci\u00f3n es generar una plantilla de Hidato v\u00e1lida aleatoriamente a partir de una cantidad de filas, de columnas y de un porcentaje de obst\u00e1culos, resolver esta plantilla para obtener un Hidato resuelto y luego realizar un proceso de eliminaci\u00f3n de una cantidad de celdas (seg\u00fan la dificultad seleccionada) cuyos valores sean mayores que 1 y menores que el m\u00e1ximo v en un orden aleatorio comprobando en cada paso que al eliminar no sea posible generar m\u00e1s de un Hidato resuelto (siendo el \u00fanico posible, el Hidato resuelto desde donde se comenz\u00f3 el proceso de eliminaci\u00f3n).</p> <ul> <li>La funci\u00f3n generate recibe el n\u00famero de filas, de columnas, el porcentaje de obst\u00e1culos y la dificultad y realiza lo siguiente: Utilizando la funci\u00f3n generateHidatoSolved genera un Hidato resuelto que utiliza como argumento al llamar a la funci\u00f3n removeCells pas\u00e1ndole adem\u00e1s como argumento a esta una permutaci\u00f3n aleatoria de las casillas del Hidato resuelto (generado por la funci\u00f3n generateHidatoSolved) que se pueden eliminar (aquellas que el valor sea mayor que 1 y menor que el m\u00e1ximo valor) y el n\u00famero de casillas que se puede eliminar seg\u00fan la dificultad devolviendo finalmente la plantilla de Hidato.</li> <li>La funci\u00f3n generateHidatoSolved recibe el n\u00famero de filas, de columnas y el porcentaje de obst\u00e1culos y realiza lo siguiente: Comprueba si la pseudo plantilla de Hidato generada aleatoriamente por la funci\u00f3n generateRandomPseudoTemplate es una plantilla de Hidato v\u00e1lida (que es posible a partir de ella llegar a un Hidato resuelto), si lo es, devuelve esa plantilla, si no, lo intenta nuevamente.</li> <li>La funci\u00f3n generateRandomPseudoTemplate recibe el n\u00famero de filas, de columnas y el porcentaje de obst\u00e1culos y realiza lo siguiente: Devuelve una pseudo plantilla (plantilla que no se ha comprobado que sea una plantilla de Hidato v\u00e1lida) con la cantidad de filas y columnas recibida como argumentos y con una cantidad de casillas (seg\u00fan el porcentaje de obst\u00e1culos) marcadas como obst\u00e1culos aleatoriamente.</li> <li>La funci\u00f3n removeCells recibe una plantilla, una permutaci\u00f3n aleatoria de las casillas que se pueden eliminar y el n\u00famero de casillas que se deben eliminar seg\u00fan la dificultad y realiza lo siguiente: Si la permutaci\u00f3n aleatoria de las casillas que se pueden eliminar es vac\u00eda o el n\u00famero de casillas que se debe eliminar seg\u00fan la dificultad es negativo se devuelve la plantilla si no se genera una nueva plantilla modificando el valor (poni\u00e9ndolo en 0) de la casilla correspondiente (seg\u00fan la permutaci\u00f3n aleatoria de las casillas) a partir de la plantilla recibida como argumento, con esta nueva plantilla comprueba si se generan m\u00e1s de un Hidato resuelto, en caso de ser as\u00ed devuelve el resultado de aplicar un llamado recursivo a removeCells pas\u00e1ndole la plantilla recibida como argumento, la cola de la permutaci\u00f3n aleatoria de las casillas que se pueden eliminar y el mismo n\u00famero de casillas que se deben eliminar (pues en ese paso no es posible eliminar la casilla porque genera m\u00e1s de un Hidato resuelto), en caso de generar solamente un Hidato resuelto devuelve el resultado de aplicar un llamado recursivo a removeCells pas\u00e1ndole la nueva plantilla, la cola de la permutaci\u00f3n aleatoria de las casillas que se pueden eliminar y un n\u00famero menos de casillas que se deben eliminar (pues en ese paso es posible eliminar la casilla porque genera solamente un Hidato resuelto).</li> </ul> <p>Ejemplo de pseudo implementaci\u00f3n en Python del algoritmo de generaci\u00f3n.</p> <pre><code>def generate(n_rows, n_cols, ratio, diff):\n    hidato_solved = generate_hidato_solved(n_rows, n_cols, ratio)\n    max_elem = n_rows * n_cols - count_obstacles(hidato_solved)\n    cells_for_remove = random_shuffle(filter(lambda cell: get_cell_value(cell) &gt; 1 and get_cell_value(cell) &lt; max_elem, get_cells(hidato_solved)))\n    cant_empty = floor(len(cells_for_remove) * diff)\n    template = remove_cells(hidato_solved, n_rows, n_cols, cells_for_remove, cant_empty)\n    return template\n\n\ndef generate_hidato_solved(n_rows, n_cols, ratio):\n    pseudo_template = generate_random_pseudo_template(n_rows, n_cols, ratio)\n    limit = n_rows * n_cols - count_obstacles(pseudo_template)\n    solves = solve(pseudo_template, 0, limit)\n    if solves:\n        return solves[0]\n    else:\n        return generate_hidato_solved(n_rows, n_cols, ratio)\n\n\ndef generate_random_pseudo_template(n_rows, n_cols, ratio):\n    cant_obs = floor(n_rows * n_cols * ratio)\n    blank_template = create_black_template(n_rows, n_cols)\n    cells_for_remove = take(cant_obs, random_shuffle(get_cells(blank_template)))\n    dark_template = reduce(lambda acc, cell: update_cell_in_table(acc, update_value_in_cell(-1, cell)), cells_for_remove, blank_template)\n    pseudo_template = update_cell_in_table(dark_template, update_value_in_cell(1, select_random_cell(dark_template)))\n    return pseudo_template\n\n\ndef remove_cells(template, n_rows, n_cols, cells_for_remove, cant_empty):\n    if not cells_for_remove or cant_empty &lt; 0:\n        return template\n    else:\n        head_cell = cells_for_remove[0]\n        tail_cells = cells_for_remove[1:]\n        empty = update_value_in_cell(0, head_cell)\n        new_template = update_cell_in_table(template, empty)\n        limit = n_rows * n_cols - count_obstacles(new_template)\n        solves = solve(new_template, 0, limit)\n        if len(take(2, solves)) &lt; 2:\n            return remove_cells(new_template, n_rows, n_cols, tail_cells, cant_empty - 1)\n        else:\n            return remove_cells(template, n_rows, n_cols, tail_cells, cant_empty)\n</code></pre>"},{"location":"blog/hidato-haskell/#implementacion-en-haskell","title":"Implementaci\u00f3n en Haskell","text":"<p>Para la implementaci\u00f3n en Haskell se utilizaron cuatro estructuras fundamentales, dos implementadas por defecto en Haskell y dos implementadas por los autores.</p> <pre><code>import Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.Set (Set, lookupMin, lookupMax)\nimport qualified Data.Set as Set\n\ndata Cell = Cell { row :: Int, column :: Int, value :: Int }\ndata Matrix = Matrix { rows :: Int, columns :: Int, matrix :: Set Cell }\n</code></pre>"},{"location":"blog/hidato-haskell/#solucionador","title":"Solucionador","text":"<p>La \"cara p\u00fablica\" del solucionador es la funci\u00f3n solveAll la cual mediante la caracter\u00edstica llamada currying de Haskell que permite una aplicaci\u00f3n parcial de una funci\u00f3n, en este caso la funci\u00f3n solveAll realiza una aplicaci\u00f3n parcial de la funci\u00f3n solveRecursiveDFS convirti\u00e9ndose la funci\u00f3n solveAll en una funci\u00f3n que recibe dos argumentos, una Matrix y una lista de enteros.</p> <pre><code>solveAll :: Matrix -&gt; [Int] -&gt; [Matrix]\nsolveAll m = solveRecursiveDFS m 1 (Cell 0 0 0) (rows m * columns m  - countObstacles m) (buildMap m)\n</code></pre> <p>En el llamado a la funci\u00f3n solveRecursiveDFS se utilizan dos funciones countObstacles y buildMap.</p> <p>La funci\u00f3n countObstacles calcula la cantidad de celdas con valor igual a <code>-1</code> auxili\u00e1ndose de la funci\u00f3n countInMatrix que permite contar la cantidad de celdas con valor igual a un n\u00famero dado. Esta funci\u00f3n se utiliza para contar la cantidad de casillas que no son obst\u00e1culos.</p> <pre><code>countInMatrix :: Int -&gt; Matrix -&gt; Int\ncountInMatrix val (Matrix _ _ cells) =\n                    foldl (\\acc cell -&gt; if value cell == val then acc + 1 else acc) 0 cells\n\ncountObstacles :: Matrix -&gt; Int\ncountObstacles = countInMatrix (-1)\n</code></pre> <p>La funci\u00f3n buildMap genera un mapa o diccionario a partir de las celdas de una matriz, utilizando como llaves los valores de las celdas y como valores las celdas. Este diccionario es utilizado posteriormente para saber si una casilla con un valor determinado se encuentra en el tablero y de ser as\u00ed acceder a ella eficientemente.</p> <pre><code>buildMap :: Matrix -&gt; Map Int Cell\nbuildMap ma@(Matrix r c m) = Set.foldl (\\acc cell -&gt; Map.insert (value cell) cell acc) Map.empty m\n</code></pre> <p>La funci\u00f3n solveRecursiveDFS recibe 6 argumentos.</p> <ol> <li>actualMatrix: En la matriz actual, representando una plantilla de Hidato v\u00e1lida con posibilidades de ser un Hidato resuelto.</li> <li>step: Es el paso del algoritmo y representa el n\u00famero que se est\u00e1 intentando rellenar, pero puede existir ya en el tablero.</li> <li>prevCell: Es la celda que tiene el valor (step <code>-1</code>), ya sea porque estaba en el tablero o porque se rellen\u00f3, este variable tiene el objetivo de disminuir la complejidad temporal del algoritmo evitando tener que realizar el procesamiento para obtener en cada paso.</li> <li>obs: Es el n\u00famero de casillas que NO son obst\u00e1culos.</li> <li>map: Es un diccionario de entero contra celdas, en la explicaci\u00f3n sobre la funci\u00f3n buildMap se puede leer m\u00e1s sobre su objetivo.</li> <li>seeds: Una lista de enteros infinita, su objetivo es ser utilizada como semilla para generar n\u00famero pseudo aleatorios utilizados en el proceso de recorrer las casillas adyacentes haciendo en cada paso del algoritmo en un orden no necesariamente igual.</li> </ol> <p>La funci\u00f3n lo que hace es comprobar si se est\u00e1 en el \u00faltimo paso (que ya se rellenaron todas las casillas posibles y se lleg\u00f3 a un Hidato resuelto) o por lo contrario realizar los llamados recursivos buscando las posibles soluciones. (La explicaci\u00f3n del algoritmo se encuentra en la secci\u00f3n Algoritmo de Soluci\u00f3n).</p> <pre><code>solveRecursiveDFS :: Matrix -&gt; Int -&gt; Cell -&gt; Int -&gt; Map Int Cell -&gt; [Int] -&gt; [Matrix]\nsolveRecursiveDFS actualMatrix step prevCell obs map seeds\n      | step == obs + 1 = [actualMatrix]\n      | otherwise = let toAdd = stepMatrix step actualMatrix prevCell map seeds\n                    in concat [ solveRecursiveDFS matrix (step + 1) prevCell obs map (tail seeds) | (matrix, prevCell) &lt;- toAdd ]\n</code></pre> <p>La funci\u00f3n stepMatrix calcula las posibles matrices o plantillas de Hidato v\u00e1lidas partiendo de una plantilla recibida como argumento y el n\u00famero que tiene que rellenar en la matriz. Esto lo hace utilizando prevCell y map para mejorar la complejidad temporal y realizar menos c\u00e1lculos adem\u00e1s de la utilizaci\u00f3n de otras funciones como getAdjacents e isAdjacent.</p> <pre><code>stepMatrix :: Int -&gt; Matrix -&gt; Cell -&gt; Map Int Cell -&gt; [Int] -&gt; [(Matrix, Cell)]\nstepMatrix step m@(Matrix rs cs ma) prevCell map seeds = if Map.notMember step map\n      then [\n            newMatrix | cell &lt;- getAdjacents prevCell rs cs step seeds,\n            let actCell = Set.elemAt (Set.findIndex cell ma) ma,\n            value actCell == 0,\n            let newMatrix = (Matrix rs cs (Set.insert cell ma), cell)\n      ]\n      else  let actCell = map Map.! step\n            in [newMatrix | isAdjacent actCell prevCell || value actCell == 1, let newMatrix = (m, actCell)]\n\ngetAdjacents :: Cell -&gt; Int -&gt; Int -&gt; Int -&gt; [Int] -&gt; [Cell]\ngetAdjacents (Cell r c v) rs cs s seeds = [\n        Cell nr nc s |\n        dr &lt;- genShuffle seeds [-1, 0, 1],\n        dc &lt;- genShuffle seeds [-1, 0, 1],\n        let (nr, nc) = (r + dr, c + dc),\n        nr &gt; 0,\n        nr &lt;= rs,\n        nc &gt; 0,\n        nc &lt;= cs,\n        not $ dr == 0 &amp;&amp; dc == 0\n    ]\n\nisAdjacent :: Cell -&gt; Cell -&gt; Bool\nisAdjacent (Cell f1 c1 v1) (Cell f2 c2 v2)\n            | Cell f1 c1 v1 == Cell f2 c2 v2           = False\n            | abs (f1 - f2) &gt;= 2 || abs (c1 - c2) &gt;= 2 = False\n            | v1 == (-1) || v2 == (-1)                 = False\n            | otherwise                                = True\n</code></pre>"},{"location":"blog/hidato-haskell/#generador","title":"Generador","text":"<p>La \"cara p\u00fablica\" del generador es la funci\u00f3n generateGame, esta recibe la cantidad de filas y columnas, el porcentaje de obst\u00e1culos, la dificultad y un l\u00edmite de tiempo que tendr\u00e1 en generador para generar la plantilla de Hidato v\u00e1lida (m\u00e1s adelante se explicar\u00e1 con m\u00e1s detalles este l\u00edmite de tiempo y porque es necesario). La funci\u00f3n devuelve una tupla, en la primera componente significa si se puedo generar la plantilla y en la segunda componente la plantilla generada (notar que si la primera componente es igual a <code>False</code>, el valor de la segunda componente no tiene significado).</p> <pre><code>generateGame :: Int -&gt; Int -&gt; Float -&gt; Difficulty -&gt; Int -&gt; IO (Bool, Matrix)\ngenerateGame rn cn ratio dif to = do\n      maybeMatrix &lt;- timeout to $ generateRandomGame rn cn ratio\n      if isNothing maybeMatrix then do\n            return (False, blankMatrix 1 1)\n      else do\n            let solution = maybe (blankMatrix rn cn) id maybeMatrix\n            let maxElem = rn * cn - countObstacles solution\n            let setForRemove = Set.filter (\\x -&gt; let v = value x in v &gt; 1 &amp;&amp; v &lt; maxElem) (matrix solution) :: Set Cell\n            randomCells &lt;- genRCellFromSet setForRemove\n            let total = Set.size setForRemove\n            let cant_empty = floor $ fromIntegral total * emptyRatio dif\n            seed &lt;- randomIO :: IO Int\n            let gen = mkStdGen seed\n            let seeds = randoms gen :: [Int]\n            let game = removeCells solution randomCells cant_empty seeds\n            return (True, game)\n</code></pre> <p>La funci\u00f3n generateGame se auxilia de la funci\u00f3n generateRandomGame para obtener un Hidato resuelto. Para realizar esta operaci\u00f3n se utiliza un tiempo l\u00edmite, debido a la naturaleza aleatoria de generateRandomGame (no se asegura que termine, porque puede dependiendo de los par\u00e1metros demorar mucho o incluso con una baj\u00edsima probabilidad realizar un ciclo infinito).</p> <p>En caso de sobrepasar el l\u00edmite de tiempo es devuelto una tupla con la primera componente en <code>False</code>. En caso de no sobrepasar el tiempo, se realiza un proceso de \"eliminaci\u00f3n\" (poner con valor cero varias celdas) comprobando en cada paso que al hacerlo se mantenga la unicidad de la soluci\u00f3n de esa plantilla (que los posibles Hidato resueltos es solamente uno).</p> <pre><code>generateRandomGame :: Int -&gt; Int -&gt; Float -&gt; IO Matrix\ngenerateRandomGame rn cn ratio = do\n      maybeTemplate &lt;- timeout 1000000 $ generateRandom rn cn ratio\n      if isNothing maybeTemplate then\n            generateRandomGame rn cn ratio\n      else do\n            let template = maybe (blankMatrix rn cn) id maybeTemplate\n            seed &lt;- randomIO :: IO Int\n            let gen = mkStdGen seed\n            let seeds = randoms gen :: [Int]\n            let solutions = solveAll template seeds\n            if null solutions then\n                  generateRandomGame rn cn ratio\n            else\n              return $ head solutions\n</code></pre> <p>El orden de las casillas escogidas para eliminar se realiza con una permutaci\u00f3n aleatoria del conjunto de casillas disponibles para eliminar (las que tengan como valor mayor que <code>1</code> y menor que el m\u00e1ximo). Luego utilizando la funci\u00f3n removeCells que lo que realiza es recorrer la permutaci\u00f3n aleatoria y comprobar si eliminando la casilla i-\u00e9sima se mantiene la unicidad, en caso de ser as\u00ed se elimina y se pasa la siguiente casilla dentro de la permutaci\u00f3n aleatoria.</p> <pre><code>removeCells :: Matrix -&gt; [Cell] -&gt; Int -&gt; [Int] -&gt; Matrix\nremoveCells sol@(Matrix rn cn cs) cells n seeds =\n      if    null cells || n &lt; 0 then\n            sol\n      else\n            let   (headCell: tailCells) = cells\n                  rowCell = row headCell\n                  colCell = column headCell\n                  empty = Cell rowCell colCell 0\n                  matrix = editMatrixCell sol empty\n                  solutions = solveAll matrix seeds\n                  isUnix = length (take 2 solutions) &lt; 2\n            in    if isUnix then\n                        removeCells matrix tailCells (n - 1) seeds\n                  else\n                        removeCells sol tailCells n seeds\n</code></pre> <p>Luego de terminado el proceso de eliminaci\u00f3n, ya sea porque se acabaron las casillas disponibles en la permutaci\u00f3n aleatoria o porque se lleg\u00f3 al n\u00famero de casillas que se deb\u00edan eliminar, se retorna la plantilla de Hidato v\u00e1lida resultante.</p>"},{"location":"blog/hidato-haskell/#manual-para-usuarios","title":"Manual para usuarios","text":"<p>Es necesario instalar Stack, este se puede instalar en la mayor\u00eda de los sistemas operativos similares a Unix, incluido macOS, y en Windows.</p> <p>Para la mayor\u00eda de los sistemas operativos Unix, la forma m\u00e1s sencilla de instalar es ejecutar:</p> <pre><code>curl -sSL https://get.haskellstack.org/ | sh\n</code></pre> <p>o:</p> <pre><code>wget -qO- https://get.haskellstack.org/ | sh\n</code></pre> <p>En Windows, puede descargar e instalar el instalador de Windows de 64 bits.</p> <p>Para otros sistemas operativos y descargas directas, consulte la gu\u00eda de instalaci\u00f3n y actualizaci\u00f3n. [3]</p> <p>Lo siguiente es clonar el repositorio de GitHub utilizando Git o descargar el .zip y descomprimirlo.</p> <p>Luego, dentro de la carpeta del proyecto ejecutar <code>stack setup</code>, despu\u00e9s <code>stack build</code> y por \u00faltimo <code>stack exec hidato-exe</code> para ejecutar el proyecto.</p> <p></p> <p>https://github.com/codestrange/declarative-programing-hidato-project</p> <p>Los comandos disponibles del Hidato son <code>4</code>.</p> <ul> <li><code>help</code>: Para ver la ayuda, tambi\u00e9n es posible ver la ayuda de un comando especifico utilizando <code>help comando</code></li> <li><code>generate</code>: Para generar una plantilla de Hidato, los argumentos son cantidad de filas, cantidad de columnas, la raz\u00f3n de la cantidad de obst\u00e1culos respecto al tama\u00f1o del tablero, la dificultad, el nombre del fichero donde se guardar\u00e1 la plantilla de Hidato y, por \u00faltimo, opcionalmente un tiempo l\u00edmite expresado en millon\u00e9simas de segundos, por defecto es un minuto. Por ejemplo: <code>generate 5 5 0.2 Normal hidato.txt</code>. Las dificultades son <code>Easy</code>, <code>Normal</code> y <code>Hard</code>.</li> <li><code>solve</code>: Para resolver un Hidato, recibe como argumento la direcci\u00f3n del fichero donde se encuentra la plantilla del Hidato a resolver. Por ejemplo: <code>solve hidato.txt</code></li> <li><code>exit</code>: Para salir del programa</li> </ul> <p></p>"},{"location":"blog/hidato-haskell/#referencias","title":"Referencias","text":"<ol> <li>P\u00e1gina sobre Haskell en la Wikipedia</li> <li>P\u00e1gina sobre Hidato en la Wikipedia</li> <li>Documentaci\u00f3n de Haskell Stack</li> </ol>"},{"location":"blog/inferfuzzy/","title":"Inferfuzzy","text":"<p>Inferfuzzy es una biblioteca de Python para implementar Sistemas de Inferencia Difusa.</p>"},{"location":"blog/inferfuzzy/#empezando","title":"Empezando","text":""},{"location":"blog/inferfuzzy/#instalacion","title":"Instalaci\u00f3n","text":"<pre><code>pip install inferfuzzy\n</code></pre>"},{"location":"blog/inferfuzzy/#uso","title":"Uso","text":"<p>Creaci\u00f3n de variables ling\u00fc\u00edsticas y sus conjuntos difusos asociados.</p> <pre><code>variable_1 = Var(\"variable_name_1\")\nvariable_1 += \"set_name_1\", ZMembership(1, 2)\nvariable_1 += \"set_name_2\", GaussianMembership(3, 2)\nvariable_1 += \"set_name_3\", SMembership(4, 6)\n\nvariable_2 = Var(\"variable_name_2\")\nvariable_2 += \"set_name_4\", GammaMembership(70, 100)\nvariable_2 += \"set_name_5\", LambdaMembership(40, 60, 80)\nvariable_2 += \"set_name_6\", LMembership(30, 50)\n</code></pre> <p>Declarar las reglas sem\u00e1nticas y el m\u00e9todo de inferencia a utilizar.</p> <pre><code>mamdani = MamdaniSystem(defuzz_func=centroid_defuzzification)\nmamdani += variable_1.into(\"set_name_1\") | variable_1.into(\"set_name_3\"), variable_2.into(\"set_name_5\")\nmamdani += variable_1.into(\"set_name_2\"), variable_2.into(\"set_name_4\")\n</code></pre> <p>Usando el m\u00e9todo de inferencia difusa para valores ingresados por el usuario.</p> <pre><code>variable_1_val = float(input())\nmamdani_result: float = mamdani.infer(variable_name_1=variable_1_val)[\"variable_name_2\"]\n</code></pre>"},{"location":"blog/inferfuzzy/#caracteristicas-del-sistema-de-inferencia","title":"Caracter\u00edsticas del Sistema de Inferencia","text":"<p>La biblioteca contiene implementados los m\u00e9todos de inferencia Mamdani y Larsen. Pero es posible implementar partiendo de una base com\u00fan otros m\u00e9todos de inferencia.</p> <p>Los m\u00e9todos de inferencia reciben una funci\u00f3n de defuzzificaci\u00f3n. La biblioteca contiene implementadas Centroide, Bisectriz, M\u00e1ximo Central, M\u00e1ximo m\u00e1s peque\u00f1o y M\u00e1ximo m\u00e1s grande.</p> <p>Durante el proceso de definici\u00f3n de los conjuntos difusos esto requieren una funci\u00f3n de membres\u00eda que puede ser implementada o utilizar una de las disponibles en la biblioteca.</p> <p>Funciones de membres\u00eda implementadas en Inferfuzzy:</p> <ul> <li>Funci\u00f3n Gamma</li> <li>Funci\u00f3n Lambda o Triangular</li> <li>Funci\u00f3n Pi o Trapezoidal</li> <li>Funci\u00f3n S</li> <li>Funci\u00f3n Z</li> <li>Funci\u00f3n Gaussiana</li> </ul> <p>La T-conorm y T-norm utilizadas en las reglas de inferencia, as\u00ed como el m\u00e9todo de agregaci\u00f3n de los conjuntos son posibles de sobrescribir, por defecto, son m\u00ednimo, m\u00e1ximo y m\u00e1ximo respectivamente.</p> <p>Es posible definir m\u00e1s de una variable de salida para el sistema de inferencia difusa implementado en la biblioteca.</p>"},{"location":"blog/inferfuzzy/#estructura-de-la-implementacion","title":"Estructura de la Implementaci\u00f3n","text":"<p>La implementaci\u00f3n se sostiene sobre 7 clases fundamentales:</p> <ul> <li><code>Membership</code></li> <li><code>BaseSet</code></li> <li><code>BaseVar</code></li> <li><code>BaseRule</code></li> <li><code>Predicate</code></li> <li><code>VarSet</code></li> <li><code>InferenceSystem</code></li> </ul>"},{"location":"blog/inferfuzzy/#membership","title":"Membership","text":"<p>Es la clase encargada de representar una funci\u00f3n de membres\u00eda junto a los puntos (llamados <code>items</code> internamente)</p> <pre><code>class Membership:\n    def __init__(self, function: Callable[[Any], Any], items: list):\n        self.function = function\n        self.items = items\n\n    def __call__(self, value: Any):\n        return self.function(value)\n</code></pre>"},{"location":"blog/inferfuzzy/#baseset","title":"BaseSet","text":"<p>Es la clase encargada de representar un conjunto difuso. Recibe como par\u00e1metros un objeto de tipo <code>Membership</code> representando la funci\u00f3n de membres\u00eda del conjunto y un m\u00e9todo de agregaci\u00f3n.</p> <pre><code>class BaseSet:\n    def __init__(\n        self,\n        name: str,\n        membership: Membership,\n        aggregation: Callable[[Any, Any], Any],\n    ):\n        self.name = name\n        self.membership = membership\n        self.aggregation = aggregation\n\n    def __add__(self, arg: \"BaseSet\"):\n        memb = Membership(\n            lambda x: self.aggregation(\n                self.membership(x),\n                arg.membership(x),\n            ),\n            self.membership.items + arg.membership.items,\n        )\n        return BaseSet(\n            f\"({self.name})_union_({arg.name})\",\n            memb,\n            aggregation=self.aggregation,\n        )\n</code></pre>"},{"location":"blog/inferfuzzy/#basevar","title":"BaseVar","text":"<p>Es la clase encargada de representar una variable ling\u00fc\u00edstica. Recibe como par\u00e1metros una funci\u00f3n de uni\u00f3n, una funci\u00f3n de intercepci\u00f3n y una lista de objetos de tipo <code>BaseSet</code> representando los conjuntos difusos de la variable.</p> <pre><code>class BaseVar:\n    def __init__(\n        self,\n        name: str,\n        union: Callable[[Any, Any], Any],\n        inter: Callable[[Any, Any], Any],\n        sets: Optional[List[BaseSet]] = None,\n    ):\n        self.name = name\n        self.sets = {set.name: set for set in sets} if sets else {}\n        self.union = union\n        self.inter = inter\n\n    def into(self, set: Union[BaseSet, str]) -&gt; VarSet:\n        set_name = set.name if isinstance(set, BaseSet) else set\n        if set_name not in self.sets:\n            raise KeyError(f\"Set {set_name} not found into var {self.name}\")\n        temp_set = self.sets[set_name]\n        return VarSet(self, temp_set, self.union, self.inter)\n</code></pre>"},{"location":"blog/inferfuzzy/#baserule","title":"BaseRule","text":"<p>Es la clase encargada de representar una regla de inferencia. Recibe como par\u00e1metro un objeto de tipo <code>Predicate</code> representando el antecedente de la regla.</p> <pre><code>class BaseRule:\n    def __init__(self, antecedent: Predicate):\n        self.antecedent = antecedent\n\n    def __call__(self, values: dict):\n        raise NotImplementedError()\n</code></pre> <p><code>BaseRule</code> no contiene consecuencias porque las consecuencias de todos los tipos de reglas no son de la misma estructura. La clase <code>Rule</code> hereda de <code>BaseRule</code> y representa las reglas en los que el sistema produce un conjunto o m\u00e1s como resultado.</p> <pre><code>class Rule(BaseRule):\n    def __init__(self, antecedent: Predicate, consequences: List[VarSet]):\n        super(Rule, self).__init__(antecedent)\n        self.consequences = consequences\n\n    def aggregate(self, set: BaseSet, value: Any) -&gt; BaseSet:\n        raise NotImplementedError()\n\n    def __call__(self, values: dict):\n        value = self.antecedent(values)\n        return {\n            consequence.var.name: self.aggregate(\n                consequence.set,\n                value,\n            )\n            for consequence in self.consequences\n        }\n</code></pre>"},{"location":"blog/inferfuzzy/#predicate","title":"Predicate","text":"<p>Es la clase encargada de representar a los antecedentes. De ella heredan cuatro clases: <code>AndPredicate</code>, <code>OrPredicate</code>, <code>NotPredicate</code> y <code>VarSet</code>. Las primeras tres para representar las relaciones l\u00f3gicas de uni\u00f3n, intercepci\u00f3n y negaci\u00f3n; y la \u00faltima representa la inclusi\u00f3n de una variable en un determinado conjunto, siendo esta la clase b\u00e1sica para representar a los antecedentes.</p> <pre><code>class Predicate:\n    def __init__(\n        self,\n        union: Callable[[Any, Any], Any],\n        inter: Callable[[Any, Any], Any],\n    ) -&gt; None:\n        self.union = union\n        self.inter = inter\n\n    def __call__(self, values: dict):\n        raise NotImplementedError()\n\n    def __and__(self, other: \"Predicate\"):\n        return AndPredicate(self, other, self.union, self.inter)\n\n    def __or__(self, other: \"Predicate\"):\n        return OrPredicate(self, other, self.union, self.inter)\n\n    def __invert__(self):\n        return NotPredicate(self, self.union, self.inter)\n</code></pre>"},{"location":"blog/inferfuzzy/#varset","title":"VarSet","text":"<pre><code>class VarSet(Predicate):\n    def __init__(\n        self,\n        var: \"BaseVar\",\n        set: BaseSet,\n        union: Callable[[Any, Any], Any],\n        inter: Callable[[Any, Any], Any],\n    ):\n        super(VarSet, self).__init__(union, inter)\n        self.var = var\n        self.set = set\n\n    def __call__(self, values: dict):\n        return self.set.membership(values[self.var.name])\n</code></pre>"},{"location":"blog/inferfuzzy/#inferencesystem","title":"InferenceSystem","text":"<p>Es la clase encargada de representar el sistema de inferencia. Recibe como par\u00e1metros las reglas y una funci\u00f3n de defuzzificaci\u00f3n y con el m\u00e9todo <code>infer</code> permite realizar la inferencia seg\u00fan los valores prove\u00eddos.</p> <pre><code>class InferenceSystem:\n    def __init__(\n        self,\n        rules: Optional[List[BaseRule]] = None,\n        defuzz_func: Optional[Callable[[BaseSet], Any]] = None,\n    ):\n        self.rules = rules if rules else []\n        self.defuzz_func = defuzz_func\n\n    def infer(\n        self,\n        values: dict,\n        defuzz_func: Optional[Callable[[BaseSet], Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        if not self.rules:\n            raise Exception(\"Empty rules\")\n        if self.defuzz_func is None and defuzz_func is None:\n            raise Exception(\"Defuzzification not found\")\n        func = self.defuzz_func if defuzz_func is None else defuzz_func\n        set: Dict[str, BaseSet] = self.rules[0](values)\n        for rule in self.rules[1:]:\n            temp: Dict[str, BaseSet] = rule(values)\n            for key in temp:\n                set[key] += temp[key]\n        result: Dict[str, Any] = {}\n        for key in set:\n            result[key] = func(set[key])\n        return result\n</code></pre>"},{"location":"blog/inferfuzzy/#ejemplo-de-como-utilizar-inferfuzzy","title":"Ejemplo de como utilizar Inferfuzzy","text":"<p>Como ejemplo se utilizar\u00e1 el siguiente problema.</p> <p>Se desea inferir el por ciento de la cantidad de un determinado producto que se ha vendido en un d\u00eda en un restaurante, cafeter\u00eda, etc.</p> <p>Por ejemplo, el producto Pollo, se desea conocer bajo determinadas condiciones que por ciento del Pollo sacado del almac\u00e9n dispuesto para venderse ese d\u00eda se termina vendiendo.</p> <p>Para la implementaci\u00f3n se seleccionaron <code>4</code> variables ling\u00fc\u00edsticas. Las primeras <code>3</code> de entrada y la \u00faltima de salida.</p> <ol> <li>Cantidad de platos o derivados del producto que se vende. Por ejemplo, retomando el ejemplo del Pollo, si se vender\u00eda Pollo Frito y Pollo Asado, la variable valdr\u00eda <code>2</code>. A esta variable le llamaremos <code>variety</code>.<ul> <li>Baja: <code>low &lt;= 2</code>. Funci\u00f3n de Membres\u00eda: Z</li> <li>Normal: <code>1 &lt;= normal &lt;= 5</code>. Funci\u00f3n de Membres\u00eda: Gaussiana</li> <li>Alta: <code>high &gt;= 4</code>. Funci\u00f3n de Membres\u00eda: S</li> </ul> </li> <li>Por ciento que representa la variable <code>variety</code> del total de platos o derivados de productos que se vende. Por ejemplo, si se vende Pollo Frito, Pollo Asado, Pescado y Cerdo la variable valdr\u00eda <code>50</code>. A esta variable se le llamar\u00e1 <code>diversity</code>.<ul> <li>Baja: <code>low &gt;= 70</code>. Funci\u00f3n de Membres\u00eda: Gamma</li> <li>Normal: <code>40 &lt;= normal &lt;= 80</code>. Funci\u00f3n de Membres\u00eda: Lambda</li> <li>Alta: <code>high &lt;= 50</code>. Funci\u00f3n de Membres\u00eda: L</li> </ul> </li> <li>Por ciento de la utilizaci\u00f3n del local, si es <code>100</code> es que el local siempre est\u00e1 lleno, si es <code>0</code> es que no asiste ning\u00fan cliente al establecimiento. A esta variable se le llamar\u00e1 <code>clients</code>.<ul> <li>Baja: <code>low &lt;= 40</code>. Funci\u00f3n de Membres\u00eda: L</li> <li>Normal: <code>30 &lt;= normal &lt;= 90</code>. Funci\u00f3n de Membres\u00eda: Lambda</li> <li>Alta: <code>high &gt;= 80</code>. Funci\u00f3n de Membres\u00eda: Gamma</li> </ul> </li> <li>Por ciento de la cantidad del producto que se vendi\u00f3 en el d\u00eda, si es <code>100</code> fue se vendi\u00f3 todo al final del d\u00eda, si es <code>50</code> fue que no se vendi\u00f3 la mitad de la cantidad. A esta variable se le llamar\u00e1 <code>sales</code>.<ul> <li>Baja: <code>low &lt;= 60</code>. Funci\u00f3n de Membres\u00eda: L</li> <li>Normal: <code>30 &lt;= normal &lt;= 90</code>. Funci\u00f3n de Membres\u00eda: Lambda</li> <li>Alta: <code>high &gt;= 90</code>. Funci\u00f3n de Membres\u00eda: Gamma</li> </ul> </li> </ol>"},{"location":"blog/inferfuzzy/#declaracion-de-las-variables-linguisticas-y-sus-conjuntos-difusos-en-inferfuzzy","title":"Declaraci\u00f3n de las variables ling\u00fc\u00edsticas y sus conjuntos difusos en Inferfuzzy","text":"<pre><code>variety_var = Var(\"variety\")\nvariety_var += \"low\", ZMembership(1, 2)\nvariety_var += \"normal\", GaussianMembership(3, 2)\nvariety_var += \"high\", SMembership(4, 6)\n\ndiversity_percent_var = Var(\"diversity\")\ndiversity_percent_var += \"low\", GammaMembership(70, 100)\ndiversity_percent_var += \"normal\", LambdaMembership(40, 60, 80)\ndiversity_percent_var += \"high\", LMembership(30, 50)\n\nclients_percent_var = Var(\"clients\")\nclients_percent_var += \"low\", LMembership(20, 40)\nclients_percent_var += \"normal\", LambdaMembership(30, 60, 90)\nclients_percent_var += \"high\", GammaMembership(80, 100)\n\nsales_percent_var = Var(\"sales\")\nsales_percent_var += \"low\", LMembership(20, 60)\nsales_percent_var += \"normal\", LambdaMembership(30, 60, 90)\nsales_percent_var += \"high\", GammaMembership(90, 100)\n</code></pre>"},{"location":"blog/inferfuzzy/#graficos-de-pertenencia-de-los-conjuntos-por-cada-variable","title":"Gr\u00e1ficos de pertenencia de los conjuntos por cada variable","text":""},{"location":"blog/inferfuzzy/#reglas-de-inferencia","title":"Reglas de Inferencia","text":"variety diversity clients sales low low low low low low normal normal low low high high low normal low low low normal normal low low normal high normal low high low low low high normal low low high high normal normal low low low normal low normal normal normal low high high normal normal low low normal normal normal normal normal normal high normal normal high low low normal high normal low normal high high normal high low low low high low normal normal high low high high high normal low low high normal normal low high normal high high high high low low high high normal low high high high normal"},{"location":"blog/inferfuzzy/#declaracion-de-las-reglas-de-inferencia-en-inferfuzzy","title":"Declaraci\u00f3n de las Reglas de Inferencia en Inferfuzzy","text":"<pre><code>mamdani = MamdaniSystem(\n    defuzz_func=centroid_defuzzification,\n)\nmamdani += (\n    variety_var.into(\"low\")\n    &amp; diversity_percent_var.into(\"low\")\n    &amp; clients_percent_var.into(\"low\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"low\")\n    &amp; diversity_percent_var.into(\"low\")\n    &amp; clients_percent_var.into(\"normal\")\n), sales_percent_var.into(\"normal\")\nmamdani += (\n    variety_var.into(\"low\")\n    &amp; diversity_percent_var.into(\"low\")\n    &amp; clients_percent_var.into(\"high\")\n), sales_percent_var.into(\"high\")\nmamdani += (\n    variety_var.into(\"low\")\n    &amp; diversity_percent_var.into(\"normal\")\n    &amp; clients_percent_var.into(\"low\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"low\")\n    &amp; diversity_percent_var.into(\"normal\")\n    &amp; clients_percent_var.into(\"normal\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"low\")\n    &amp; diversity_percent_var.into(\"normal\")\n    &amp; clients_percent_var.into(\"high\")\n), sales_percent_var.into(\"normal\")\nmamdani += (\n    variety_var.into(\"low\")\n    &amp; diversity_percent_var.into(\"high\")\n    &amp; clients_percent_var.into(\"low\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"low\")\n    &amp; diversity_percent_var.into(\"high\")\n    &amp; clients_percent_var.into(\"normal\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"low\")\n    &amp; diversity_percent_var.into(\"high\")\n    &amp; clients_percent_var.into(\"high\")\n), sales_percent_var.into(\"normal\")\nmamdani += (\n    variety_var.into(\"normal\")\n    &amp; diversity_percent_var.into(\"low\")\n    &amp; clients_percent_var.into(\"low\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"normal\")\n    &amp; diversity_percent_var.into(\"low\")\n    &amp; clients_percent_var.into(\"normal\")\n), sales_percent_var.into(\"normal\")\nmamdani += (\n    variety_var.into(\"normal\")\n    &amp; diversity_percent_var.into(\"low\")\n    &amp; clients_percent_var.into(\"high\")\n), sales_percent_var.into(\"high\")\nmamdani += (\n    variety_var.into(\"normal\")\n    &amp; diversity_percent_var.into(\"normal\")\n    &amp; clients_percent_var.into(\"low\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"normal\")\n    &amp; diversity_percent_var.into(\"normal\")\n    &amp; clients_percent_var.into(\"normal\")\n), sales_percent_var.into(\"normal\")\nmamdani += (\n    variety_var.into(\"normal\")\n    &amp; diversity_percent_var.into(\"normal\")\n    &amp; clients_percent_var.into(\"high\")\n), sales_percent_var.into(\"normal\")\nmamdani += (\n    variety_var.into(\"normal\")\n    &amp; diversity_percent_var.into(\"high\")\n    &amp; clients_percent_var.into(\"low\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"normal\")\n    &amp; diversity_percent_var.into(\"high\")\n    &amp; clients_percent_var.into(\"normal\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"normal\")\n    &amp; diversity_percent_var.into(\"high\")\n    &amp; clients_percent_var.into(\"high\")\n), sales_percent_var.into(\"normal\")\nmamdani += (\n    variety_var.into(\"high\")\n    &amp; diversity_percent_var.into(\"low\")\n    &amp; clients_percent_var.into(\"low\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"high\")\n    &amp; diversity_percent_var.into(\"low\")\n    &amp; clients_percent_var.into(\"normal\")\n), sales_percent_var.into(\"normal\")\nmamdani += (\n    variety_var.into(\"high\")\n    &amp; diversity_percent_var.into(\"low\")\n    &amp; clients_percent_var.into(\"high\")\n), sales_percent_var.into(\"high\")\nmamdani += (\n    variety_var.into(\"high\")\n    &amp; diversity_percent_var.into(\"normal\")\n    &amp; clients_percent_var.into(\"low\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"high\")\n    &amp; diversity_percent_var.into(\"normal\")\n    &amp; clients_percent_var.into(\"normal\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"high\")\n    &amp; diversity_percent_var.into(\"normal\")\n    &amp; clients_percent_var.into(\"high\")\n), sales_percent_var.into(\"high\")\nmamdani += (\n    variety_var.into(\"high\")\n    &amp; diversity_percent_var.into(\"high\")\n    &amp; clients_percent_var.into(\"low\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"high\")\n    &amp; diversity_percent_var.into(\"high\")\n    &amp; clients_percent_var.into(\"normal\")\n), sales_percent_var.into(\"low\")\nmamdani += (\n    variety_var.into(\"high\")\n    &amp; diversity_percent_var.into(\"high\")\n    &amp; clients_percent_var.into(\"high\")\n), sales_percent_var.into(\"normal\")\n</code></pre> <p>De manera an\u00e1loga ser\u00eda para Larsen utilizando la clase <code>LarsenSystem</code>.</p>"},{"location":"blog/inferfuzzy/#resultados","title":"Resultados","text":"<pre><code>Variety Value: 10\nDiversity Percent: 50\nClients Percent: 50\nMamdani: 35.11%\nLarsen 32.82%\n\nVariety Value: 2\nDiversity Percent: 100\nClients Percent: 100\nMamdani: 96.22%\nLarsen 100.00%\n\nVariety Value: 4\nDiversity Percent: 40\nClients Percent: 100\nMamdani: 60.00%\nLarsen 60.00%\n</code></pre>"},{"location":"blog/inferfuzzy/#analisis-de-los-resultados","title":"An\u00e1lisis de los Resultados","text":"<p>De los resultados, se puede observar que los m\u00e9todos de Mamdani y Larsen obtienen resultados similares. A primera vista no es posible validar si los resultados se asemejan a la realidad, para esto es imprescindible la colaboraci\u00f3n de un experto en el tema para la correcta definici\u00f3n de las variables, la asignaci\u00f3n de las funciones de membres\u00eda m\u00e1s correctas as\u00ed\u0301 como la definici\u00f3n de las reglas asociadas.</p>"},{"location":"blog/inferfuzzy/#conclusiones","title":"Conclusiones","text":"<p>En este escrito se muestra las l\u00edneas generales de c\u00f3mo utilizar Inferfuzzy, adem\u00e1s de que muestra la capacidad de los sistemas de inferencia difusos para afrontar problem\u00e1ticas donde la definici\u00f3n utilizando la l\u00f3gica cl\u00e1sica no est\u00e9 clara o que la soluci\u00f3n utilizando esta sea demasiado engorrosa.</p>"},{"location":"blog/inferfuzzy/#referencias","title":"Referencias","text":"<ol> <li>Sistemas de Control con Lo\u0301gica Difusa: Me\u0301todos de Mamdani y de Takagi-Sugeno-Kang (TSK). Autor: Samuel Diciembre Sanahuja</li> <li>Temas de Simulaci\u00f3n. Autor: Dr. Luciano Garc\u00eda Garrido</li> <li>First Course on Fuzzy Theory and Applications. Autor: Kwang H. Lee</li> </ol>"}]}